#!/usr/bin/perl

=head

 AStool.pl -- generate AS event result and stat the result

 20150419: add AS_splice_site_stat.pl to AStool
 20150418: change and combine script to AStool
 20140710: init
=cut

use strict;
use warnings;
use FindBin;
use IO::File;
use Getopt::Std;
use Bio::SeqIO;

my $version = 0.1;
my $debug = 0;

my %options;
getopts('a:b:c:d:e:f:g:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:h', \%options);
unless (defined $options{'t'} ) { usage($version); }

if	($options{'t'} eq 'analyze')	{ as_event_analyze(\%options, \@ARGV); }	# as event analyze
elsif	($options{'t'} eq 'spsites')	{ as_splice_site(\%options, \@ARGV); }		# as splice site
else	{ usage($version); }

=head
 as_event_analyze: identify and classify as event 
=cut
sub as_event_analyze
{
	my ($options, $files) = @_;

	my $usage = qq'
USAGE: $0 -t analyze [options] input_gtf > output_report

';
	print $usage and exit unless defined $$files[0];
	my $input_gtf = $$files[0];
	die "[ERR]file not exist $input_gtf\n" unless -s $input_gtf;
	die "[ERR]file suffix $input_gtf\n" unless $input_gtf =~ m/\.gtf/;

	my $cutoff = 50;
	$cutoff = $$options{'c'} if (defined $$options{'c'} && $$options{'c'} > 0);

	# sort and asta
	my $sort_gtf = $input_gtf; $sort_gtf =~ s/\.gtf$/_sort\.gtf/;
	my $asi_gtf  = $input_gtf; $asi_gtf  =~ s/\.gtf$/_ASI\.gtf/;
	my $asi_gtf_gz = $asi_gtf.".gz";

	my $cmd1 = "astalavista -t sortGTF -i $input_gtf -o $sort_gtf";
	my $cmd2 = "astalavista -t asta -i $sort_gtf -o $asi_gtf_gz";
	my $cmd3 = "gunzip $asi_gtf_gz";

	run_cmd($cmd1, 1);
	run_cmd($cmd2, 1);
	run_cmd($cmd3, 1);
	#unlink($sort_gtf);

	# get stat of AS event
	my $as_stat_perl = '/home/kentnf/06lncRNA/tomato_paired-end/07AScategory/AS_event_stat.pl';
	my $cmd4 = "perl $as_stat_perl $asi_gtf $cutoff";
	run_cmd($cmd4, 1);
}

=head2
 as_event_stat: generate statistics info for as result generated by astalavista
 input: input_gtf, cutoff
 ouput: no. of 4 main AS events, and other AS events
=cut
sub as_event_stat
{
	my ($input_gtf, $cutoff) = @_;

	# init number 
	my ($AA, $AD, $ES, $IR, $other, $total) = (0,0,0,0,0,0);

	$total = `wc -l $input_gtf`; chomp($total); $total =~ s/^\s+//; $total =~ s/\s+.*//ig;
	die "[Error]input gtf file\n" unless $total > 0;

	# init hash
	my %type_stat;
	my %trans_type_stat;
	my %struc_type_count;	# key: structure, AS type; value: count

	# main
	my $fh = IO::File->new($input_gtf) || die $!;
	while(<$fh>)
	{
		chomp;
		next if $_ =~ m/^#/;
		my @a = split(/\t/, $_);
		die "Error in line $_\n" if scalar @a < 9;
		if ($a[8] =~ m/structure "(\S+)";/)
		{
			my $struc = $1;
			my @type = as_type($struc);
			#print join(", ", @type),"\t$struc\n";
		
			my $type_all = join(",", @type);
			if ( defined $struc_type_count{$struc}{$type_all} )
			{
				$struc_type_count{$struc}{$type_all}++;
			}
			else
			{
				$struc_type_count{$struc}{$type_all} = 1
			}
	
			my %type;
			my @uniq_type;
			foreach my $t (@type) {
				if ( defined $type_stat{$t} ) { $type_stat{$t}++; } 
				else { $type_stat{$t} = 1; }

				unless ( defined $type{$t} ) {
					$type{$t} = 1;
					push(@uniq_type, $t);
				}
			}

			@uniq_type = sort @uniq_type;
			my $uniq_type = join(", ", @uniq_type);

			if ( defined $trans_type_stat{$uniq_type} )
			{
				$trans_type_stat{$uniq_type}++;
			}
			else
			{
				$trans_type_stat{$uniq_type} = 1;
			}
		}
		else
		{
			die "Error in line $_\n";
		}
	}
	$fh->close;

	foreach my $t (sort keys %type_stat) 
	{
		#print $t."\t".$type_stat{$t}."\n";
	}

	#print "-----------------\n";

	#foreach my $t (sort keys %trans_type_stat)
	#{
	#	print $t."\t".$trans_type_stat{$t}."\n";
	#}

	foreach my $stru (sort keys %struc_type_count)
	{
		foreach my $t ( sort keys %{$struc_type_count{$stru}})
		{
			if ($t eq 'AA' && $stru eq "1-,2-" )	{ $AA = $struc_type_count{$stru}{$t}; }
			if ($t eq 'AD' && $stru eq "1^,2^" )	{ $AD = $struc_type_count{$stru}{$t}; }
			if ($t eq 'ES' && $stru eq "0,1-2^" )	{ $ES = $struc_type_count{$stru}{$t}; }
			if ($t eq 'IR' && $stru eq "0,1^2-" )	{ $IR = $struc_type_count{$stru}{$t}; }

			if ($struc_type_count{$stru}{$t} >= $cutoff)
			{
				print $stru,"=>",$t,"=>",$struc_type_count{$stru}{$t},"\n";
			}
		}
	} 
	$other = $total - $AA - $AD - $ES - $IR;
	print "$input_gtf\t$AA\t$AD\t$ES\t$IR\t$other\t$total\n";
}

# kentnf: subroutine
sub as_type
{
	my $struc = shift;

	my @type; # array for type, the members should be AD, AA, ES, IR
	# construct the hash for each point (splicing site):
	# key: number of splicing site
	# value of transcript {ts} : 1(left), 2(right)
	# value of as code    {as} : as code (^ ~)
	# could get stat_change_num, source_stat, sink_stat from the hash
	# the number of changed site, and the as code (^ -) could be traced 
	my %site;
	my @a = split(/,/, $struc);
	die "[Error]Struc: $struc\n" unless scalar(@a) == 2;	
	my @s1 = $a[0] =~ m/(\d+)/g; 
	my @s2 = $a[1] =~ m/(\d+)/g;
	my @as1 = $a[0] =~ m/(\^|-)/g;
	my @as2 = $a[1] =~ m/(\^|-)/g;
	if ($a[0] eq '0' ) { @s1 = (); @as1 = (); }
	die "[Error]left AS code do not match site number: $a[0]\n" unless scalar(@s1) == scalar(@as1);
	die "[Error]left AS code do not match site number: $a[1]\n" unless scalar(@s2) == scalar(@as2);
	for (my $i=0; $i<@s1; $i++) {
		$site{$s1[$i]}{'ts'} = 1;
		$site{$s1[$i]}{'as'} = $as1[$i];
	}
	for (my $i=0; $i<@s2; $i++) {
		$site{$s2[$i]}{'ts'} = 2;
		$site{$s2[$i]}{'as'} = $as2[$i];
	}
	my $total_site_num = scalar(@s1) + scalar(@s2);
	die "[Error]num of splicing site is not even number: $total_site_num\n$struc\n" unless ($total_site_num % 2 == 0);
	die "[Error]splicing site not start from 1: $struc\n" unless defined $site{"1"}{'ts'};

	for (my $i=1; $i<=$total_site_num; $i = $i+2) 
	{
		my $j = $i+1;	# i,j should be a pair of splicing events
		die "[Error]undef splicing site num: $i\n$struc\n" unless defined $site{$i}{'ts'};
		die "[Error]undef splicing site code:$i\n$struc\n" unless defined $site{$i}{'as'};
		die "[Error]undef splicing site num: $j\n$struc\n" unless defined $site{$j}{'ts'};
		die "[Error]undef splicing site code:$j\n$struc\n" unless defined $site{$j}{'as'};
		my $i_tsstat = $site{$i}{'ts'};
		my $i_ascode = $site{$i}{'as'};
		my $j_tsstat = $site{$j}{'ts'};
		my $j_ascode = $site{$j}{'as'};

		if ( $i_tsstat ne $j_tsstat ) 	# for event AD or AA
		{
			die "[Error]Diff AS code: $i $j\t$i_ascode $j_ascode\n$struc\n" if $i_ascode ne $j_ascode;
			#if 	($i_ascode eq '^') { push(@type, 'AD') if scalar @type == 0 || $type[scalar(@type)-1] ne 'AD'; }
			#elsif 	($i_ascode eq '-') { push(@type, 'AA') if scalar @type == 0 || $type[scalar(@type)-1] ne 'AA'; }
			if     ($i_ascode eq '^') { push(@type, 'AD'); }
			elsif  ($i_ascode eq '-') { push(@type, 'AA'); }

		}
		else				# for event ES and IR
		{
			die "[Error]Same AS code: $i $j\t$i_ascode $j_ascode\n$struc\n" if $i_ascode eq $j_ascode;

			# add code for detect another type of AS mu
			#if	($i_ascode eq '^') { push(@type, 'IR') if scalar @type == 0 || $type[scalar(@type)-1] ne 'IR'; }
			#elsif   ($i_ascode eq '-') { push(@type, 'ES') if scalar @type == 0 || $type[scalar(@type)-1] ne 'ES'; }
			if	($i_ascode eq '^') { push(@type, 'IR'); }
			elsif   ($i_ascode eq '-') { push(@type, 'ES'); }
		}
	}
	return @type;
}

=head1
 AS_splice_site_stat.pl -- get number of different splice site
 Yi Zheng
 201406:init 
=cut
sub as_splice_site
{
	my ($options, $files) = @_;

	my $usage = qq'
USAGE: perl $0 -t spliceSite -g genome_sequence input_gtf 
	
';
	print $usage and exit unless defined $$files[0];
	my $input_gtf = $$files[0];
	die "[ERR]file not exist\n" unless -s $input_gtf;
	
	print $usage and exit unless defined $$options{'g'};
	my $genome = $$options{'g'};
	die "[ERR]file not exist\n" unless -s $genome;

	# put the transcript exon info to hash
	# key: tid; value: exon1_start exon1_end exon2_start exon2_end ....
	my %tid_info;
	my $fh = IO::File->new($input_gtf) || die $!;
	while(<$fh>)
	{
		chomp;
		next if $_ =~ m/^#/;
		my @a = split(/\t/, $_);
		# SL2.40ch00	Cufflinks	exon	3300	3326	.	+	.	gene_id "XLOC_000001"; transcript_id "TCONS_00000001"; exon_number "1"; oId "CUFF.1.1"; class_code "u"; tss_id "TSS1"; lincRNA "1";
		die "[ERR]col num $_\n" if scalar @a < 9;

		if ($a[2] eq 'exon')
		{
			if ($a[8] =~ m/transcript_id "(\S+)"/) 
			{
				my $tid = $1;
				if (defined $tid_info{$tid}{'exon'})
				{
					$tid_info{$tid}{exon}.="\t".$a[3]."\t".$a[4];
				}
				else
				{
					$tid_info{$tid}{exon} = $a[3]."\t".$a[4];
				}

				if (defined $tid_info{$tid}{'chr'}) 
				{
					die "Error, chr for $tid\n" if $tid_info{$tid}{'chr'} ne $a[0];
				}
				else
				{
					$tid_info{$tid}{'chr'} = $a[0];
				}

				if (defined $tid_info{$tid}{'strand'})
				{
					die "Error, strand for $tid\n" if $tid_info{$tid}{'strand'} ne $a[6];
				}
				else
				{
					$tid_info{$tid}{'strand'} = $a[6];
				}
			}
			else
			{
				die "Error in line $_\n";
			}
		}
	}
	$fh->close;

	# convert tid exon hash to split site hash, 
	# key: Chr exon_end 
	# value: exon start1, ...... 
	# key: chr exon_end, exon_start
	# value: strand
	my %site;
	my %site_strand;

	foreach my $tid (sort keys %tid_info)
	{
		my $chr = $tid_info{$tid}{'chr'};
		my $strand = $tid_info{$tid}{'strand'};
		my @exon = split(/\t/, $tid_info{$tid}{'exon'});
		next if scalar @exon == 2;
		die "Error in exon num for $tid\n$tid_info{$tid}{'exon'}\n" if scalar @exon % 2 == 1;

		# check the exon order
		my $pre_exon = $exon[0];
		for(my $i=1; $i<@exon; $i++) {
			if ( $exon[$i] < $pre_exon ) {
				die "Error in exon order for $tid\n$tid_info{$tid}{'exon'}\n";
			} {
				$pre_exon = $exon[$i];
				next;
			}
		}

		shift @exon;
		pop @exon;

		# coreate hash for site
		for(my $i=0; $i<@exon; $i=$i+2) {
			my $start = $exon[$i];
			my $end = $exon[$i+1];
		
			if (defined $site_strand{$chr."\t".$start."\t".$end} ) 
			{
				if ( $site_strand{$chr."\t".$start."\t".$end} eq $strand ) {
	
				} else {
					#$site{$chr."\t".$start."\t".$end} = ".";
				}
				next;
			}
			else
			{
				$site_strand{$chr."\t".$start."\t".$end} = $strand;
			}

			if ( defined $site{$chr."\t".$start} )
			{
				$site{$chr."\t".$start}.= "\t".$end;
			}
			else
			{
				$site{$chr."\t".$start}	= $end;
			}
		}
	}

	# get splicing site, then put it to junc_stat hash
	# key: GT-AG
	# value: number of this site
	my %junc_stat;

	my $in = Bio::SeqIO->new(-format=>'fasta', -file=>$genome);
	while(my $inseq = $in->next_seq)
	{
		my $chr = $inseq->id;
		my $seq = $inseq->seq;
		my $len = $inseq->length;

		# below start is the exon end
		# below end is the exon start
		for(1 .. $len) 
		{
			my $start = $_;

			if ( defined $site{$chr."\t".$start} )
			{
				my @end = split(/\t/, $site{$chr."\t".$start});
				foreach my $end (@end) 
				{
					my $strand = $site_strand{$chr."\t".$start."\t".$end};

					my $start_base = uc(substr($seq, $start, 2));
					my $end_base = uc(substr($seq, $end-3, 2));

					my $junction;
					if ($strand eq "+") 
					{
						$junction = $start_base."-".$end_base;
					}
					elsif ($strand eq "-") 
					{
						$junction = $start_base."-".$end_base;
						my $rev_junc = reverse($junction);
						$rev_junc =~ tr/ACGTacgt-/TGCAtgca-/;
						$junction = $rev_junc;
					}
					else
					{
						next;
					}

					if (defined $junc_stat{$junction})
					{
						$junc_stat{$junction}++;
					}
					else
					{
						$junc_stat{$junction} = 1;
					}
				}
			}
		}
	}

	# report junc start
	foreach my $j (sort keys %junc_stat)
	{
		print $j."\t".$junc_stat{$j}."\n";
	}
}

=head2
 run_cmd : run command
=cut
sub run_cmd
{
        my ($cmd, $debug) = @_;
        print "[DEBUG]".$cmd."\n" if $debug;
        system($cmd) && die "[Error][CMD]$cmd\n";
}

=head2
 usage: print usage information
=cut
sub usage
{
        my $usage = qq'
USAGE: $0 -t tool 

        analyze         analyze AS events number
	spsites		count the number of splice site

';
        print $usage; exit;
}

